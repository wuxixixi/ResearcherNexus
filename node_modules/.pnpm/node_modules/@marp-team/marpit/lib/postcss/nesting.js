"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nesting = exports.default = void 0;
var _postcssIsPseudoClass = _interopRequireDefault(require("@csstools/postcss-is-pseudo-class"));
var _postcssNesting = _interopRequireDefault(require("postcss-nesting"));
var _postcss_plugin = _interopRequireDefault(require("../helpers/postcss_plugin"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/** @module */

const {
  Rule: applyPostCSSNesting
} = (0, _postcssNesting.default)();
const matcher = /:is\((?:section|:root)\b/;
const nesting = exports.nesting = (0, _postcss_plugin.default)('marpit-postcss-nesting', () => (root, helpers) => {
  const rules = [];

  // Note: Use walk instead of walkRules to include nested rules
  root.walk(node => {
    if (node.type !== 'rule') return;
    rules.push(node);
    node.__marpitNestingOriginalSelector = node.selector;
  });

  // Apply postcss-nesting
  root.walkRules(rule => applyPostCSSNesting(rule, helpers));
  const {
    Rule: applyPostCSSIsPseudoClass
  } = (0, _postcssIsPseudoClass.default)({
    onComplexSelector: 'warning'
  }).prepare();
  for (const rule of rules) {
    if (rule.__marpitNestingOriginalSelector !== rule.selector && matcher.test(rule.selector)) {
      // Apply postcss-is-pseudo-class only to transformed rules that is
      // including `:is() selector starting from `section` element or `:root`
      // pseudo-class
      applyPostCSSIsPseudoClass(rule, helpers);
    }
    delete rule.__marpitNestingOriginalSelector;
  }
});
var _default = exports.default = nesting;