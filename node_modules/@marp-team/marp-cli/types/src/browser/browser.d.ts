import type { Browser as PuppeteerBrowser, ProtocolType, LaunchOptions, Page } from 'puppeteer-core';
import type TypedEventEmitter from 'typed-emitter';
export type BrowserKind = 'chrome' | 'firefox';
export type BrowserProtocol = ProtocolType;
export interface BrowserOptions {
    path: string;
    timeout?: number;
}
type BrowserEvents = {
    close: (browser: PuppeteerBrowser) => void;
    disconnect: (browser: PuppeteerBrowser) => void;
    launch: (browser: PuppeteerBrowser) => void;
};
declare const Browser_base: new () => TypedEventEmitter<BrowserEvents>;
export declare abstract class Browser extends Browser_base implements AsyncDisposable {
    #private;
    static readonly kind: BrowserKind;
    static readonly protocol: BrowserProtocol;
    path: string;
    protocolTimeout: number;
    timeout: number;
    private _puppeteerDataDir;
    private _puppeteer;
    constructor(opts: BrowserOptions);
    get kind(): BrowserKind;
    get protocol(): ProtocolType;
    launch(opts?: LaunchOptions): Promise<PuppeteerBrowser>;
    withPage<T>(fn: (page: Page) => T): Promise<T>;
    close(): Promise<void>;
    [Symbol.asyncDispose](): Promise<void>;
    browserInWSLHost(): Promise<boolean>;
    resolveToFileURI(filePath: string): Promise<string>;
    /** @internal Overload launch behavior in subclass */
    protected abstract launchPuppeteer(opts: LaunchOptions): Promise<PuppeteerBrowser>;
    /** @internal */
    protected generateLaunchOptions(mergeOptions?: LaunchOptions): Promise<LaunchOptions>;
    /** @internal */
    protected puppeteerDataDir(): Promise<string>;
}
export {};
